<!DOCTYPE HTML>
<!--
	Forty by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Object Oriented Programming</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Header -->
				<!-- Note: The "styleN" class below should match that of the banner element. -->
					<header id="header" class="alt style2">
						<a href="index.html" class="logo"><strong>Dheeran Calder</strong>
						<nav>
							<a href="#menu">Menu</a>
						</nav>
					</header>

				<!-- Menu -->
					<nav id="menu">
						<ul class="links">
							<li><a href="index.html">Home</a></li>
							<li><a href="landing.html">Object-Oriented Programming</a></li>
							<li><a href="generic.html">Network & information Security</a></li>
							<li><a href="elements.html">WIP</a></li>
						</ul>
						<ul class="actions stacked">
							<li><a href="#" class="button primary fit">Get Started</a></li>
						</ul>
					</nav>

				<!-- Banner -->
				<!-- Note: The "styleN" class below should match that of the header element. -->
					<section id="banner" class="style2">
						<div class="inner">
							<span class="image">
								<img src="images/pic07.jpg" alt="" />
							</span>
							<header class="major">
								<h1> Object Oriented Programming</h1>
							</header>
							<div class="content">
								<p>Object Object-Orientated module ePortfolio.<br />
								Below you will find reflections, assignments and artefacts organized from the units.</p>
							</div>
						</div>
					</section>

				<!-- Main -->
					<div id="main">

						<!-- One -->
							<section id="one">
								<div class="inner">
									<header class="major">
										
									</header>
									<h3>Module Overview </h3>
									<p>Object-Oriented Programming (OOP), a popular approach to software development that uses objects and classes to organize code. Students will learn how to create classes and objects in Python, and use them to manipulate data. The module covers advanced topics like inheritance and polymorphism, which are used to design complex programs. Upon completion, students will have the skills to design and implement their own OOP programs. </p>	
									<h3>Learning outcomes </h3>
									<li>Appraise and critically evaluate object-oriented programming compared to other programming paradigms. </li>
									<li>Design and implement programs that demonstrate appropriate use of object-oriented design principles. </li>
									<li>Select and use appropriate data structures for a given problem. </li>
									<li>Propose object-oriented solutions using an appropriate modelling language, such as UML. </li>
									</ol>	
									<hr />
									<header class="major">
										<h2>Unit 1: An Introduction to Python Programming and the OO Programming Paradigm </h2>
									</header>
									
									<p>The first unit of the module introduces the object oriented programming paradigm, the syntax and the method used to form classes in python. Also introducing the 5 major features of object oriented programming: </p>
									<li>Classes: OOP is based on the group of classes which are templates or blueprints that define the properties and behaviour of an object. </li>
								        <li>Encapsulation: is a way to hide the implementation details of an object from the outside. </li>
								        <li>Inheritance: allows for a new class to be based on an existing one. Inheriting the properties and methods. </li>								
								        <li>Polymorphism: allows objects to change to take on different forms or types </li>								
								        <li>Abstraction: is the process of removing unnecessary detail from an object, leaving only the essential characteristics. </li>
								        <br>
								        <h3><u>Article review </u></h3>
								        <p> The article by Di Silvestro & Nadir (2021) discusses the topic of E-portfolios. With the benefits of making e-portfolios for students being explored in detail. The article discusses the effect that e-portfolios have on the enhancement of student experience and engagement to higher learning programs. This article is one of the first studies into finding the true value of the implementation of an e-portfolio of which presented many less commonly associated benefits such as the development of professional confidence. Personally, as a post graduate student making an e-portfolio for the first time I expected the benefits to be simply as a showcase of work and progress, however according to this article the act of building the portfolio itself helps to build many professional skills and serves as form of revision for the content learned during the course. This can help build confidence for students as it shows a clear progression in skills over duration of the module. </p>
								        
									<P><b><i> References: Nadir, H. & Di Silvestro, F., 2020. The power of ePortfolio development to foster reflective and deeper learning in an online. 1(1), pp. 154-164.</i></b></P>
							                <br>
								        <h3><u>Discussion Forum </u></h3>
									<p>The research paper by Padhy et al. (2018) breaks down the object-oriented metrics that influence the reusability and its overall assets. Eleven key assets have been identified to affect the reusability of object-oriented software apart from programming code. Six of these assets have been identified to have greater influence on the overall reusability compared to other assets, these have been ranked in detail and shown below. </p>								
									<ol>
									<li> Requirement analysis (RA): Its essential to understand the parameters for which a project needs to take place. Without this effective progress cannot be started. </li>
                      							<li> Knowledge requirements (KR): The knowledge in the form of experiences, ideas and reasoning are key assets that are applicable to any type of project. </li>								
									<li> Design Patterns (DP): The recycling of older and used designs when applicable can help to speed up the creation of new projects. </li>
									<li> Algorithm used in the programs (AP): The reuse of algorithms can help to aid developers and makes the designing new programs quicker and easier. </li>
									<li> Architecture driven approach (ADP): The general structure of a project can be reused in similar projects to help speed up the planning and development stages. </li>								
									<li> Documentation in project (DIP): The documentation process helps to keep track of all development aspects this can directly be used to contribute to reducing time for future projects by boosting knowledge base of a development team. </li>								
								        </ol>
									<p> The remaining 5 unranked assets include: Modules in the program (MIP), Service Contracts (SC), Test Cases/ test design (TCTD), Models in the project (MIP), Used in the data project (UD). These clearly have a role in the reusability of software however when compared to the 6 ranked I personally feel these have a smaller impact. </p>								
									<P><b><i> References: Padhy, N., Satapathy, S., & Singh, R.P. (2018) 'State-of-the-Art Object-Oriented Metrics and Its Reusability: A Decade Review' </i></b></P>								
									<br>
									<h3><u>Artefacts: Protected and unprotected variables </u></h3>
									<p>In OOP class attributes can be either protected or unprotected variables. An unprotected variable can be accessed or modified from any point in the program while a protected variable can only be accessed and modified within its the class and subclasses. </p>									
									<p>The following program shows a contact book with the application of protected and unprotected variables. So that some information is public such as the name while the phone number and email are private. </p>									
									<span class="image main"><img src="pictures/OOUnit1.png" alt="" /></span>									
									<p><a href="https://github.com/dheeranc/OOP-coding-/blob/source/protected%20and%20unprotected%20variables">source code.</a></p>
								
								
									<hr />
									<header class="major">
										<h2>Unit 2: Object Oriented Analysis - Initial Steps towards Programming in Python </h2>
									</header>
									<p>The second unit discusses the initial steps to start OOP within python after the process of analysing the programs domain by applying UML designs of both use case and state machine diagrams. Use case diagrams in particular provide an important visual aid to understanding the different actor and main features present in a system. </p>									
						
									<h3><u>Artefact: UML Design</u></h3>
								        <p><b>Use case diagram for a self-driving car system:</b></p>	
									<span class="image main"><img src="pictures/OOUnit2.png" alt="" /></span>
									<br>
									<h3>Extension Activities: </h3>
									<p> The following shows an employee related program that can retain employee details such as name, age and salary as well as allowing for an employee to book days of annual leave and count how many days remain. This uses both protected and unprotected variables in the case of the employees details. </p>								
									<span class="image main"><img src="pictures/OOUnit2.1.png" alt="" /></span>
									<p><a href="https://github.com/dheeranc/OOP-coding-/blob/source/Employee%20detail%20and%20annual%20leave">source code.</a></p>
									<br>
							
									<hr />
									<header class="major">
										<h2>Unit 3:  UML </h2>
									</header>
									<p>The third unit discusses the different types of UML diagrams and the importance of each of them, most importantly the class diagram. The class diagram is essential to be understanding on how to implement it as it is heavily involved in OOP coding. The third unit also provides a key understanding into the different stages of software development and the overall system design. </p>								
									
								<h3><u> Artefact :UML and development life cycles </u></h3>
									<p>UML is a modelling technique that shows the step wise details of components involved with the development of a system. UML models contain elements such as the use actors, classes and packages involved in a project. It is used to show visually a specific perspective. The two main types of UML diagrams are structural and behavioural diagrams. Structural diagrams show the different  elements present in the system while behavioural diagrams show the how the object in the system interact with each other to create a functioning system. </p>
									<p>Use case diagram is utilized at the requirement gathering stage of development. This is in order to identify the different scenarios present in the system. </p>								
									<p>Class diagram are used during the design stage to represent the different classes and objects present as well as the relationships between them. </p>								
									<p>Sequence diagrams are used during the development stage to show the different interactions between objects or components present in the system and how these occur. </p>								
									<p>Activity diagrams are used during the both the requirement and packaging stage to show flow of activities and decision paths present in the system. </p>
									<p>State diagrams are useful at any stage of development except the final packing stage. It is used the model the behaviour of object in the system. This shows the different states of an object or component can be in and the events that cause these changes.</p>								
								<p><u>Below shows a state machine diagram made for a washing machine system: </u></p>
								<span class="image main"><img src="pictures/OOUnit3.png" alt="" /></span>
								<P><b><i> References: Jacobson, I., Rum baugh, J. & Booch, G., (2004). The Unified Modeling Language Reference Manual. 2 ed.</p></b></i>
									<br>
								<h3><u>Discussion Forum</u></h3>
								<p><u> Summary Post</u></p>
									<p>My initial post outlined the ranking for which I believed best suited the impact of the eleven key assets identified in the paper by Padhy et al, which affect the reusability of object-oriented software. My ranking consisted of the top six most important factor and the remaining 5 were deemed as less impactful. After reviewing the views of my peers in regards to this topic the general consensus was that is seemed to be arbitrary to rank the individual factors based on their merits in isolation. This is due to in reality the factors are applied together to make the biggest impact on reusability. It is also clear that it depends on an individual’s perspective on which factors present the most value as amongst my peers the lists generated were all unique. Although the general consensus is that requirement analysis is the most impactful factor. 
I believe that in my initial post I discounted the other unranked 5 factors, as I only saw basic implications for each of these however test cases seemingly has a larger impact than I initially gave it. This is due to my focus on development rather than user experience and accessibility where a good and effective testing plan will help to create the best possible software, that as a whole can be reused with minor changes in the future. </p>
									<p>Overall the article by Padhy et al, has improved my understanding of the complex nature of software development having to account for not just the current project but how aspects can be  reused in order to streamline future projects. </p>										
									<P><b><i> References: Padhy, N., Satapathy, S., & Singh, R.P. (2018) 'State-of-the-Art Object-Oriented Metrics and Its Reusability: A Decade Review' </i></b></P>								
									<br>	
										
									<hr />
									<header class="major">
										<h2>Unit 4:  Applying a UML Model to a Program Implementation: UML in Practice </h2>
									</header>
									<p>The fourth unit discusses the implementation of UML designs to a program and the further creation of other types of UML designs not yet explored such as an activity diagram. This unit also introduced the different types of views for which the types of UML diagram represents. </p>
									<ol>
									<p> These are the: use case view point which addresses the functionally based on the user perspective. </p>
									<p> The structural view which describes the overall structure present in the system. </p>
									<p> The behavioural view which describes the dynamic behaviour present in the system between object and components. </p>
									<p> Implementation view which shows how a system is implemented with the use of source codes and the overall framework used in development. </p>								
									<p> Deployment view describes the actual deployment of the system these include the hardware and infrastructure needed to run said system. </p>
									<p> Process view point which describes the combination and cooperation of multiple aspects of the system to handles processes and tasks. Examples of these are sequence and activity diagrams. </p>								
								</ol>
									<br>
								
								
								<h3><u>Artefact: UML design </u></h3>
									<p> Activity diagrams display the sequence of activities, decision points and the differing branching paths present in the system. The following activity diagram displays a self-driving car system involving navigation, environmental and internal systems of the car. </p>									
									<span class="image main"><img src="pictures/OOUnit4.png" alt="" /></span>
									<br>
								
								
								
									<hr />
									<header class="major">
										<h2>Unit 5: More on Classes </h2>
									</header>
								<p>The fifth unit focuses further on developing the concept of classes. It introduces and further develops the concepts of classes, inheritance and data structures. Specifically polymorphism and variable constructors developed upon, these concepts provide the ability to execute class methods based on object creation.  </p>									
									
									<h3><u>Artefact: Polymorphism </u></h3>
								
									<p> Polymorphism is a fundamental concept of object oriented programming that allows different types of objects to be treated as if they are the same type. Therefore a single method or function can be used to operate different objects as long as they share the common super class. This allows for code reusability and modularity key concept of OOP. </p>
									<p><u> The following python program shows the use of polymorphism for a program usable within a system for the driverless car: </u></p>	
									<span class="image main"><img src="pictures/OOUnit5.png" alt="" /></span>
									<p><a href="https://github.com/dheeranc/OOP-coding-/blob/source/navigation%20polymorphism">source code.</a></p>
									<br>
									
						
								
								<hr />
									<header class="major">
										<h2>Unit 6: Abstract Methods and Interfaces </h2>
									</header>
									<p>The sixth unit discusses the concepts of abstract methods and interfaces. The concept of encapsulation is also introduced which involves the grouping of attributes and different data structures. An abstract method is declared in a class but does not have any implementation. This is for the purpose of providing a blueprint for its subclasses to implement the functionality of it. An interface is similar to this however an interface can only contain abstract methods and constants. </p>									
								<h3><u> Artefacts: Abstraction in Object Oriented Programming </u></h3>
								<p><u> Metrics used to assess the features of an object oriented program </u> </p>
								<p>There are several metrics used to assess the features of an object oriented program. These metrics provide a way to measure the quality of a programs design and implementation, therefore helping to identify potential issues and aspects to be improved. The most commonly used metrics used are as follows: </p>
								<ol>
								<p>Coupling, this measures the degrees of interdependence that is present between set classes of a program. A high coupling indicates that changes to one class will heavily affect others, making the program harder to change and modify. </p>
								<p> Cohesion, this measures the degree to which member of a class are related to each other. High cohesion indicated that the member of the class are closely related and work together to achieve a common goal. </p>						
								<p> Inheritance depth, this measures the number of levels inside a class hierarchy. The higher this depth the more complex and difficult it is to understand. </p>
								<p> Method complexity, this measures the difficulty of individual methods in a class. A high method complexity can indicate that a method is doing too much and may be too complex. </p>
								<p> Code coverage, this measures the amount of code that is executed during testing. High code coverage indicated that most of the code has been tested and is less likely to contains errors.  </p>
								<p> Cyclomatic complexity, this is most used metric. It measure the number of independent paths in a program. The higher the complexity the more the difficult and harder to modify or understand. </p>				
								</ol>
								<P><b><i> References: Brij, & Goel, Dr. Brij Mohan & Pradeep, Prof & Bhatia, Pradeep. (2013). An Overview of Various Object Oriented Metrics. International Journal of Information Technology and Systems (IJITS) </P></b></i>		
								<br>
								<p>Below show a python program which has three abstract methods and one subclass. This is used to allow a user to perform a three basic banking operations these are deposit, withdraw and checking the balance. While the “checking account” serves as the subclass and actually allows for the implementation of the operations for a user due to the use of “abstract method” decorator for the purpose of showing the use of the subclass. </p>
								<span class="image main"><img src="pictures/OOUnit6.png" alt="" /></span>
								<p><a href="https://github.com/dheeranc/OOP-coding-/blob/source/Banking%20program">source code.</a></p>
									<br>
								<h3>Article Review </h3>
								<p>The article by Knox et al. (2018) discusses many the concept of a modelling management resource system in the form of Pynsim. Component based modelling as described in this article is an approach to modelling a complex system by breaking it down into smaller  components which can then be modelled and analysed separately. These components can then be combined back together to a larger system with the behaviour of the system determined via the interactions between these components. Component based modelling frameworks depend on several elements such as the component architecture, component libraries, model composition as well as verification and finally the documentation stage. 
This link to Pynsim a central focus of this paper, Pynsim is a python based simulation framework that allows for the modelling and analysis of complex dynamic systems. It is built to be flexible as well as modular. It can even provide pre built components for common systems. Pynsim includes a simulation engine that execute a model and produce outputted data. In conclusion, Pynsim is a powerful for modelling a simulating complex systems in a user friendly way and due to its python based architecture, allows for easy integration with different python libraries and tools. </p>
								<P><b><i> References: Knox, S. et al. (2018) “A python framework for multi-agent simulation of Networked Resource Systems,” Environmental Modelling & Software, 103, pp. 16–28. </P></b></i>	
								<br>
								
								
								
						
								
								<hr />
									<header class="major">
										<h2>Unit 7: Debugging / Error Handling, Data Structures and Data Search </h2>
									</header>
									<p>The seventh unit discusses the concepts of debugging and error handling as well as the concepts of data structure and searching. The seventh unit also marked the submission of the first assignment of the module which involved a accumulation of all the UML concepts previously discussed. </p>
									<br>
								<h3><u>Artefacts: Data structures</u> </h3>
									<p>Data structures are essential for object-oriented development because they enable developers to efficiently and systematically organize, store, and work with data. Lists are one of the most commonly used data structures in object-oriented programming. They facilitate easier data management and manipulation by allowing developers to store collections of objects or values. Another frequently used data structure in object-oriented programming is dictionaries. They enable programmers to store data as key-value pairs, allowing for data retrieval and updating. Sets are another structure in object-oriented programming that represent a collection of unordered unique elements. They allow developers to use set operations such as union, intersection and difference.  </p>									
									<p> These data structures can be used to represent a variety of real-world objects or concepts in object-oriented programming these help to support object-oriented development by allowing developers to organize, store, and manipulate data in an efficient and structured manner. </p>
									<p> The below program shows the creation of a nested dictionary of data on cars within a Car class. The program is extended to work with the dictionary by calling the following methods: items(), keys(), values(): </p>										
									<span class="image main"><img src="pictures/OOUnit7.png" alt="" /></span>
									<p><a href="https://github.com/dheeranc/OOP-coding-/blob/source/dictionary%20car">source code.</a></p>
									<br>
									<h3><u> Reflection: Design Proposal  </u></h3>
									<p> The first assignment of this modules was to make a design proposal for a piece of software that could help with the processes of a self-driving or automated car. This involved the creation of five different UML designs these included the: class, use case, sequence, activity and state diagrams. I found some of these more difficult to apply than other. The use case diagram and especially the sequence diagram were particularly difficult for me due to having less experience making these but I felt as though the finished product of these did reflect what I wanted to the best of my ability. My program that I detailed in the design documentation described a data transferring program that could take data acquired from the sensors package and send it to the correct aspects of the car system such as the navigation of perception modules to analyse. Tis would then be send to the central control unit that would make decisions on the cars current objects changing to be in line with any detections or environmental dangers. This would then be sent to the cars interface to change the steering, acceleration and deceleration. This is the basis of my program, at the begin of this task I found it difficult to start as I was concerned with trying to program the entirety of a self-driving car system. I soon realised that this was too far out of my abilities and had to limit the program to just dealing with the navigation, environmental and movement of the car by transferring data and storing data to the correct components in different data types such as lists, stacks, queues and dictionaries. </p>										
								
									
									
									
									
									<hr />
									<header class="major">
										<h2>Unit 8: Data Structures and Data Search in Practice </h2>
									</header>
								<p> The eight unit of the module focuses on data structures and data searching. It focuses on understanding how data sets are compared using set operation. This is useful as it can help to organize coding structure and understand different types of data.  </p>
								<h3><u>Artefact: Data Structures </u></h3>
									<p>Set operations such as Union, Intersection, Difference and Symmetric difference can be used to manipulate sets of data that represent various characteristics of the car's environment, such as its sensors, external surrounding, and driving rules. </p>
								<p>The <b>union</b> of two sets A and B is a new set that contains all the elements that are in A or B or both. For a self-driving car, the union operation could be used to combine the data from multiple sensors such as lidar, radar, and cameras, into a single set representing the car's environmental perception. </p>
								<p> The <b>intersection</b> of two sets A and B is a new set that contains all the elements that are in both A and B. For a self-driving car, the intersection operation could be used to filter conflicting data from different sensors retaining only the consistent data that represents the car's true environment. </p>
								<p> The <b>difference</b> of two sets A and B is a new set containing all the elements that are in A but not in B. For a self-driving car, the difference operation can be used to identify and remove unwanted anomalies from the environment set. </p>
								<p> The <b>symmetric difference</b> of two sets A and B is a new set containing all the elements that are in either A or B but not inside both. For a self-driving car, this can be used to compare and contrast the data from two sets, these set can be anything where the car need to detects changes or differences between modules such as perception. </p>
								<br>
								<p><u>The following Python program shows a simple name directory that carries out a linear search on a list data structure. </u></p>
								<span class="image main"><img src="pictures/OOUnit8.png" alt="" /></span>
									<p><a href="https://github.com/dheeranc/OOP-coding-/blob/source/list%20search">source code.</a></p>
									<br>
								<h3> Discussion Forum: Metamodel design for OO design for IoT </h3>
								<p>The article by Fortino et al. (2015) discusses the design and application of a metamodel. We can apply this information to determine the strength and weaknesses of designing a metamodel for object oriented design of the internet of things (IoT). The metamodel can provide a standardised way of designing IoT systems which can help to reduce complexity. As well as it provide an abstract view of a system which can help developers understand the system in more detail. The drawbacks of this are that metamodels can add an additional level of complexity to the design process, while at the same time the opposite can occur where processes and features are generalised for the purpose of making a metamodel. The metamodel omit certain aspects of the system and not cover all aspects of IoT design such as the security, privacy and scalability. </p>
								<p> Overall the design of metamodels for object-oriented design of the IoT can have many benefits, but it also requires consideration of its  weaknesses as well. </p>
								<P><b><i> References: Fortino, G., Guerrieri, A., Russo, W. & Savaglio, C. (2015) Towards a Development Methodology for Smart Object-Oriented IoT Systems: A Metamodel Approach. 2015 IEEE International Conference on Systems, Man, and Cybernetics. 1297-1302. DOI: 10.1109/SMC.2015.231. </P></b></i>							
								<br>
					
						
						                        <hr />
									<header class="major">
										<h2> Unit 9: Packaging and Testing </h2>
									</header>
								<p>The ninth unit is a continuation on testing approaches, it reiterates how consistent debugging and testing is vital for an effective development of a system. This unit introduces different types of testing, these are: manual, automated and black box testing. These are used to ensure a viable product after the development stage. </p>
								<h3><u>Artefact: Errors and testing </u></h3>
									<p>Cyclomatic complexity is one of the most commonly used metrics for assessing the complexity of an object oriented program. It can provide a qualitative measure of the independent paths present in a program. Although useful it doesn’t not provide full view of the complexity of a program as it does not take into account code semantics or the actual design of the program. There are alternative metrics that can be used separately or alongside cyclomatic complexity these are discussed below: </p>
									<ol>
									<p>Code lines, this is a simple metric which counts the total lines of code used in the program. Although this does not always give an accurate representation due to different programming languages and they differing designs of a program but it can still provide a simple way to measure the complexity and size. </p>
										<p>The maintainability index uses multiple factors such as the cyclomatic complexity and code length to provide a metric of how simple it is to edit, maintain and update a program. The higher this index the easier it is to understand and modify. </p>
										<p>The cohesion and coupling measure the degree to which different components of a program are connected together. High cohesion and low coupling are usually signs of a good design. </p>
										<p> The general view that I’ve concluded from these paper is that the best metric depends on the situation, with the most effectively commonly being a combination of multiple metrics.  </p>
								</ol>
								<p><b><i> References: </p></b></i>
									<li>Gujar, C.R. (2019) “Use and analysis on cyclomatic complexity in software development,” International Journal of Computer Applications Technology and Research, 8(5), pp. 153–156. /li>
						<li> Tiwari, U. and Kumar, S. (2014) “Cyclomatic complexity metric for component based software,” ACM SIGSOFT Software Engineering Notes, 39(1), pp. 1–6./li>
						<li> Brij, & Goel, Dr. Brij Mohan & Pradeep, Prof & Bhatia, Pradeep. (2013). An Overview of Various Object Oriented Metrics. International Journal of Information Technology and Systems (IJITS) - ISSN 2277–9825. 2. 18-27 </li>
				<br>
				
				
										
										
							
						                       
				                                        <hr />
									<header class="major">
										<h2>Unit 10: Testing Code in Practice </h2>
									</header>
									<p>The tenth unit focuses on the various methods and reasons for testing and debugging these link directly to the second assignment of module ‘system implementation’. </p>
						
						<h3><u>Artefact: Testing </u></h3>
									<p> Testing and debugging are essential for software development. The testing phase is the process of identifying defects and errors in the software, while the debugging phase is the process of fixing said errors. The following are the stages are the different types of testing and debugging that can be implemented: </p>
					
						<ol>
							<p> <b>Unit Testing</b>, is a type of testing that tests the individual units or components of the software. It is usually conducted in the coding phase of development. The purpose of unit testing is to identify and fix errors and defects in individual units before the integration into a larger system.	</p>	
							<p> <b>Integration Testing</b>, involves testing the interaction between differing units or components of the software. This type of testing helps identify defects that arise due to interactions between components.</p>										
							<p> <b>System Testing</b>, is the process of testing the entire software system as a whole to ensure that it meets the specified requirements. </p>
							<p> <b>Acceptance Testing</b>, is the process of testing the software to ensure that it meets the user's requirements and expectations. It is usually conducted via the client.</p>
							<p> <b>Performance Testing</b>, is a type of testing that tests the performance and responsiveness of the software under different conditions.</p>
							<p> <b>Security Testing</b>, is a type of testing that tests the security of the software and identifies any vulnerabilities or weaknesses that may be exploited. </p>
							<p> <b>Debugging</b>, Debugging is the process of identifying and fixing defects and errors in the software. </p>
						</ol>	
						<p> In conclusion the testing and debugging phase is critical in ensuring the quality and reliability of the software, and it should be conducted thoroughly to reduce the risk of defects and errors in software. </p>						
						
						<br>
						<h3> Discussion forum: Summary post </h3>
						<p> After the initial discussion posts from my peers about the topic of object oriented design of IoT system, it seems the general consensus was that metamodels present value to the design process however does have some major drawbacks. </p>
						<p> Two major strengths statued in the initial post are as follows. The metamodel can provide a standardised way of designing IoT systems which can help to reduce complexity. As well as it provide an abstract view of a system which can help developers understand the system in more detail. Something that I initially missed in my initial post was some other  key benefits of metamodel design which links directly to OOP, that being reusability and flexibility.
The metamodel can help identify common patterns and reusable components of the system which can help to reduce the development time and resources. While the meta model can support multiple implementations and platforms. This can improve the flexibility and adaptability. </p>
						<p> The rest of my views regarding the weakness remain relatively the same these being, that metamodels can add an additional level of complexity to the design process, while at the same time the opposite can occur where processes and features are generalised for the purpose of making a metamodel. </p>
						
						
									
									<P><b><i>Reference: Fortino, G., Guerrieri, A., Russo, W. & Savaglio, C. (2015) Towards a Development Methodology for Smart Object-Oriented IoT Systems: A Metamodel Approach. 2015 IEEE International Conference on Systems, Man, and Cybernetics</i></b></P>
				<br>
						<h3> Packaging and testing </h3>
						<p> The following program shows the use of appropriate comments and documentation to support sample code given. this refers to the activity 1 and 2 of seminar preperation.						
						<span class="image main"><img src="pictures/OOUnit10.png" alt="" /></span>
									<p><a href="https://github.com/dheeranc/OOP-coding-/blob/source/python%20add%20comments">source code.</a></p>
									<br>
							
							
							
								</div>
							</section>

						<!-- Two -->
							<section id="two" class="spotlights">
								<section>
	
									<div class="content">
										<div class="inner">
											<header class="major">
												<h3>Unit 11</h3>
											</header>
											<p>Reflections </p>
											<ul class="actions">
												<li><a href="Unit11OOP.html" class="button">Learn more</a></li>
											</ul>
										</div>
									</div>
								</section>
								<section>
									<div class="content">
										<div class="inner">
											<header class="major">
												<h3>Unit 12</h3>
											</header>
											<p>Object-Oriented Programming Complete Module Reflection </p>
											<ul class="actions">
												<li><a href="Unit12OOP.html" class="button">Learn more</a></li>
											</ul>
										</div>
									</div>
								</section>
							</section>

						<!-- Three -->
							<section id="three">
								<div class="inner">
									<header class="major">
										<h2>Professional Skills Matrix and Action plan</h2>
									</header>
									<p>Achivements, Goals & Actions</p>
									<ul class="actions">
										<li><a href="PROFESSOOP.html" class="button next">Get Started</a></li>
									</ul>
								</div>
							</section>

					</div>

				<!-- Footer -->
					<footer id="footer">
						<div class="inner">
							<ul class="icons">
								<li><a href="#" class="icon brands alt fa-github"><span class="label">GitHub</span></a></li>
								<li><a href="#" class="icon brands alt fa-linkedin-in"><span class="label">LinkedIn</span></a></li>
							</ul>
							<ul class="copyright">
								<li>&copy; Untitled</li><li>Design: <a href="https://html5up.net">HTML5 UP</a></li>
							</ul>
						</div>
					</footer>

			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>
